3. 다음문장에서 빈칸을 채우시오
4. # 리스트에서 최대값 찾기
def maxIndex(plist):
    maxitem = plist[0]
    saveindex = 0
    for index in range(1, len(plist)-1):
        if maxitem < plist[index]:
            maxitem = plist[index] 
            saveindex = index
    return saveindex

if __name__ == "__main__":
    mylist = [ 3, 10, 27, 88, 99, 52 ]
    maxindex = maxIndex(mylist)
    print("최대값의 위치는 ", maxindex)

시간 복잡도 = O(n) (전체 값 비교해야하기 때문)
5. 
6. deep copy하고 얉은 복사 
C = list(A)  # list 함수를 이용하는 방법 - 주어진 인수를 가지고 새로운 리스트를 만든다.
             # 리스트 객체의 copy 메서드(함수)를 이용하는 방법
             # 위의 두 가지의 방법을 깊은 복사
D = A.copy()
A[1] = 200
print("리스트 C는 ", C)
print("리스트 D는 ", D)
7. 가능 한 것으로 바뀜 4번이 틀림
8. 
9.  코드문제 빈칸

12. linked list 사용해서 스택 구현
20. 순차탐색 이진탐색 (순차탐색은 앞에서 부터 하나씩 비교 , 이진탐색은 중간 값에서 나누고 도 중간값을 나눈다.
21. 루트노드 맨위에 , 단말노드는 자식노드가 없으면 , 자손노드는 자기 밑으로 있는 애들 전부 다, 자손노드와 자식노드 구분 , 부모노드와 조상노드 구분, 레벨은 1부터 시작(위에서), 차수는 자식노드의 갯수, 트리의 차수는 전체노드의 차수중에서 최대 값, 트리의 높이
22. 배열 표현법과 링크표현법 n  c(자식) = 2n, 2n+1 p(부모) = m//2  0번째 사용하지 않는다 A노드1 A의 자식노드는 2번과 3번에 들어간다. B의 자식노드는 4번 B의 오른쪽 자식노드가 없기 때문에 5번은 빈다. C의 자식노드는 6번 7번에 들어가게 된다. 배열로 그리기   (이진 트리에서만 가능함)
링크 표현법 [][A][]
    [][B][None]    [][C][] 이런식 없는 노드 쪽은 None 링크해야함
23. 최소힙트리 루트노드에 오는 값을 빼라(최소) (배열의 0번째 미사용)   이진트리 만들어 두고 부모는 자식보다 작아야 한다(최소힙) 최대힙은 부모가 항상 자식노드보다 커야함,    루트 노드값을 빼고 오름차순으로 루트노드에 오는 건 맨 마지막 노드 거기서 이제 최소힙트리 정렬
24. inorder방식은 왼쪽 루트 오른쪽 순으로 찾아가고  preorder방식은 루트 왼쪽 오른쪽 순, postorder 방식은 루트 왼쪽 오른쪽 루트 순 (어떤 방식이든 스택을 사용해야한다) 되부름 방식에서는 (스택을 안써도 된다) 코드 3줄 방식에 따라 문장 순서가 바뀐다
25. 최대힙을 구성하고 데이터를 추가 및 삭제하는 코드 (마지막에 데이터를 넣어두고 힙정렬 한다.) 
